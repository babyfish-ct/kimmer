package org.babyfish.kimmer

import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.withContext
import org.babyfish.kimmer.runtime.AsyncDraftContext
import org.babyfish.kimmer.runtime.DraftSpi
import org.babyfish.kimmer.runtime.SyncDraftContext
import java.lang.UnsupportedOperationException
import kotlin.reflect.KClass

/**
 * Create new immutable data by original data and user code
 *
 * Example:
 * ```
 * fun test() {
 *     // 1. Create object
 *     val book = new(Book::class).by {
 *         name = "The book"
 *         store().name = "The store"
 *         authors() += new(Author::class).by {
 *             name = "The first author"
 *         }
 *         authors() += new(Author::class).by {
 *             name = "The second author"
 *         }
 *     }
 *
 *     // 2. Create a new object based on the current object.
 *     // This is the core value of *kimmer*.
 *     val book2 = new(Book::class).by(book) {
 *         name += "!"
 *         sotre().name += "!"
 *         for (author in authors()) {
 *             author.name += "!"
 *         }
 *     }
 * }
 * ```
 *
 * @param type The immutable interface type
 * @return The helper object with the API generated by *kimmer-ksp*,
 * it's inline-class so that there is no unnecessary cost.
 */
inline fun<T: Immutable> new(type: KClass<T>): SyncCreator<T> =
    SyncCreator(type)

/**
 * Create new immutable data by original data and asynchronous user code
 *
 * Example:
 * ```
 * suspend fun testAsync() {
 *     // 1. Create object
 *     val book = newAsync(Book::class).by {
 *         delay(100)
 *         name = "The book"
 *         store().name = "The store"
 *         authors() += newAsync(Author::class).by {
 *             delay(100)
 *             name = "The first author"
 *         }
 *         authors() += newAsync(Author::class).by {
 *             delay(100)
 *             name = "The second author"
 *         }
 *     }
 *
 *     // 2. Create a new object based on the current object.
 *     // This is the core value of *kimmer*.
 *     val book2 = newAsync(Book::class).by(book) {
 *         delay(100)
 *         name += "!"
 *         sotre().name += "!"
 *         for (author in authors()) {
 *             author.name += "!"
 *         }
 *     }
 * }
 * ```
 *
 * @param type The immutable interface type
 * @return The helper object with the API generated by *kimmer-ksp*,
 * it's inline-class so that there is no unnecessary cost.
 */
inline fun<T: Immutable> newAsync(type: KClass<T>): AsyncCreator<T> =
    AsyncCreator(type)

/**
 * The object of this class is return by the function[new].
 *
 * it's helper object with the API generated by *kimmer-ksp*,
 * this class is inline so that there is no unnecessary cost.
 */
@JvmInline
value class SyncCreator<T: Immutable>(
    val type: KClass<T>
)

/**
 * The object of this class is return by the function[newAsync].
 *
 * it's helper object with the API generated by *kimmer-ksp*,
 * this class is inline so that there is no unnecessary cost.
 */
@JvmInline
value class AsyncCreator<T: Immutable>(
    val type: KClass<T>
)

/**
 * The object of this class is return by the function[SyncDraft.new].
 *
 * it's helper object with the API generated by *kimmer-ksp*,
 * this class is inline so that there is no unnecessary cost.
 */
@JvmInline
value class SyncDraftCreator<T: Immutable>(
    val type: KClass<T>
)

/**
 * The object of this class is return by the function[AsyncDraft.newAsync].
 *
 * it's helper object with the API generated by *kimmer-ksp*,
 * this class is inline so that there is no unnecessary cost.
 */
@JvmInline
value class AsyncDraftCreator<T: Immutable>(
    val type: KClass<T>
)

/**
 * Create new data by old data and user code.
 *
 * In general, developer will not call this function directly.
 * *kimmer-ksp* will generate more friendly inline functions to wrap it.
 *
 * @param type The immutable interface type
 * @param base The original immutable data, this function creates new data based on it.
 * If it's null, that means to create data from scratch.
 * @param block The user code to modify the draft object.
 * @return The new immutable data.
 */
@Suppress("UNCHECKED_CAST")
fun <T: Immutable> produce(
    type: KClass<T>,
    base: T? = null,
    block: Draft<T>.() -> Unit
): T =
    withSyncDraftContext { ctx, isOwner ->
        ctx.createDraft(type, base).let { draft ->
            draft.block()
            if (isOwner) {
                (draft as DraftSpi).`{resolve}`() as T
            } else {
                draft as T
            }
        }
    }

/**
 *
 * Create new draft by old data and user code.
 *
 * - In general, developer will not call this function directly.
 *   *kimmer-ksp* will generate more friendly inline functions to wrap it.
 *
 * - This function can only be called in the lambda of [produce],
 *   otherwise, an [UnsupportedOperationException] will be raised.
 *
 * @param type The immutable interface type
 * @param base The original immutable data, this function creates new data based on it.
 * If it's null, that means to create data from scratch.
 * @param block The user code to modify the draft object.
 * @return The new mutable draft.
 * @exception UnsupportedOperationException This function isn't called under the lambda of [produce]
 */
@Suppress("UNCHECKED_CAST")
fun <T: Immutable, D: SyncDraft<T>> produceDraft(
    type: KClass<T>,
    base: T? = null,
    block: D.() -> Unit
): D =
    withSyncDraftContext(false) { ctx, _ ->
        val draft = ctx.createDraft(type, base) as D
        draft.block()
        draft
    }

/**
 * Create new data by old data and asynchronous user code.
 *
 * In general, developer will not call this function directly.
 * *kimmer-ksp* will generate more friendly inline functions to wrap it.
 *
 * @param type The immutable interface type
 * @param base The original immutable data, this function creates new data based on it.
 * If it's null, that means to create data from scratch.
 * @param block The user code to modify the draft object.
 * @return The new immutable data.
 */
@Suppress("UNCHECKED_CAST")
suspend fun <T: Immutable> produceAsync(
    type: KClass<T>,
    base: T? = null,
    block: suspend Draft<T>.() -> Unit
): T =
    withAsyncDraftContext { ctx, isOwner ->
        ctx.createDraft(type, base).let { draft ->
            draft.block()
            if (isOwner) {
                (draft as DraftSpi).`{resolve}`() as T
            } else {
                draft as T
            }
        }
    }

/**
 * Create new draft by old data and asynchronous user code.
 *
 * - In general, developer will not call this function directly.
 *   *kimmer-ksp* will generate more friendly inline functions to wrap it.
 *
 * - This function can only be called in the lambda of [produceAsync],
 *   otherwise, an [UnsupportedOperationException] will be raised.
 *
 * @param type The immutable interface type
 * @param base The original immutable data, this function creates new data based on it.
 * If it's null, that means to create data from scratch.
 * @param block The user code to modify the draft object.
 * @return The new mutable draft.
 * @exception UnsupportedOperationException This function isn't called under the lambda of [produceAsync]
 */
@Suppress("UNCHECKED_CAST")
suspend fun <T: Immutable, D: AsyncDraft<T>> produceDraftAsync(
    type: KClass<T>,
    base: T? = null,
    block: suspend D.() -> Unit
): D =
    withAsyncDraftContext(false) { ctx, _ ->
        val draft = ctx.createDraft(type, base) as D
        draft.block()
        draft
    }
