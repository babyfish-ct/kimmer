package org.babyfish.kimmer

import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.withContext
import org.babyfish.kimmer.runtime.AsyncDraftContext
import org.babyfish.kimmer.runtime.DraftSpi
import org.babyfish.kimmer.runtime.SyncDraftContext
import java.lang.UnsupportedOperationException
import kotlin.coroutines.AbstractCoroutineContextElement
import kotlin.coroutines.CoroutineContext
import kotlin.reflect.KClass

/**
 * Create new immutable data by original data and user code
 *
 * Example:
 * ```
 * fun test() {
 *     // 1. Create object
 *     val book = new(Book::class).by {
 *         name = "The book"
 *         store().name = "The store"
 *         authors() += new(Book::class).by {
 *             name = "The first author"
 *         }
 *         authors() += new(Book::class).by {
 *             name = "The second author"
 *         }
 *     }
 *
 *     // 2. Create a new object based on the current object.
 *     // This is the core value of *kimmer*.
 *     val book2 = new(Book::class).by(book) {
 *         name += "!"
 *         sotre().name += "!"
 *         for (author in authors()) {
 *             author.name += "!"
 *         }
 *     }
 * }
 * ```
 *
 * @param type The immutable interface type
 * @return The helper object with the API generated by *kimmer-ksp*,
 * it's inline-class so that there is no unnecessary cost.
 */
inline fun<T: Immutable> new(type: KClass<T>): SyncCreator<T> =
    SyncCreator(type)

/**
 * Create new immutable data by original data and asynchronous user code
 *
 * Example:
 * ```
 * suspend fun testAsync() {
 *     // 1. Create object
 *     val book = newAsync(Book::class).by {
 *         delay(100)
 *         name = "The book"
 *         store().name = "The store"
 *         authors() += newAsync(Book::class).by {
 *             delay(100)
 *             name = "The first author"
 *         }
 *         authors() += newAsync(Book::class).by {
 *             delay(100)
 *             name = "The second author"
 *         }
 *     }
 *
 *     // 2. Create a new object based on the current object.
 *     // This is the core value of *kimmer*.
 *     val book2 = newAsync(Book::class).by(book) {
 *         delay(100)
 *         name += "!"
 *         sotre().name += "!"
 *         for (author in authors()) {
 *             author.name += "!"
 *         }
 *     }
 * }
 * ```
 *
 * @param type The immutable interface type
 * @return The helper object with the API generated by *kimmer-ksp*,
 * it's inline-class so that there is no unnecessary cost.
 */
inline fun<T: Immutable> newAsync(type: KClass<T>): AsyncCreator<T> =
    AsyncCreator(type)

/**
 * The object of this class is return by the function[new].
 *
 * it's helper object with the API generated by *kimmer-ksp*,
 * this class is inline so that there is no unnecessary cost.
 */
@JvmInline
value class SyncCreator<T: Immutable>(
    val type: KClass<T>
)

/**
 * The object of this class is return by the function[newAsync].
 *
 * it's helper object with the API generated by *kimmer-ksp*,
 * this class is inline so that there is no unnecessary cost.
 */
@JvmInline
value class AsyncCreator<T: Immutable>(
    val type: KClass<T>
)

/**
 * The object of this class is return by the function[SyncDraft.new].
 *
 * it's helper object with the API generated by *kimmer-ksp*,
 * this class is inline so that there is no unnecessary cost.
 */
@JvmInline
value class SyncDraftCreator<T: Immutable>(
    val type: KClass<T>
)

/**
 * The object of this class is return by the function[AsyncDraft.newAsync].
 *
 * it's helper object with the API generated by *kimmer-ksp*,
 * this class is inline so that there is no unnecessary cost.
 */
@JvmInline
value class AsyncDraftCreator<T: Immutable>(
    val type: KClass<T>
)

/**
 * Create new data by old data and user code.
 *
 * In general, developer will not call this function directly.
 * *kimmer-ksp* will generate more friendly inline functions to wrap it.
 *
 * @param type The immutable interface type
 * @param base The original immutable data, this function creates new data based on it.
 * If it's null, that means to create data from scratch.
 * @param block The user code to modify the draft object.
 * @return The new immutable data.
 */
fun <T: Immutable> produce(
    type: KClass<T>,
    base: T? = null,
    block: Draft<T>.() -> Unit
): T =
    draftContextLocal
        .get()
        ?.let {
            it.createDraft(type, base).apply {
                block()
            } as T
        } ?: SyncDraftContext()
        .let {
            draftContextLocal.set(it)
            try {
                it.createDraft(type, base).let { draft ->
                    draft.block()
                    (draft as DraftSpi).`{resolve}`() as T
                } as T
            } finally {
                draftContextLocal.remove()
            }
        }

/**
 *
 * Create new draft by old data and user code.
 *
 * - In general, developer will not call this function directly.
 *   *kimmer-ksp* will generate more friendly inline functions to wrap it.
 *
 * - This function can only be called in the lambda of [produce],
 *   otherwise, an [UnsupportedOperationException] will be raised.
 *
 * @param type The immutable interface type
 * @param base The original immutable data, this function creates new data based on it.
 * If it's null, that means to create data from scratch.
 * @param block The user code to modify the draft object.
 * @return The new mutable draft.
 * @exception UnsupportedOperationException This function isn't called under the lambda of [produce]
 */
fun <T: Immutable, D: SyncDraft<T>> produceDraft(
    type: KClass<T>,
    base: T? = null,
    block: D.() -> Unit
): D =
    draftContextLocal
        .get()
        ?.let {
            val draft = it.createDraft(type, base) as D
            draft.block()
            return draft
        } ?: throw UnsupportedOperationException(
            "'produceDraft' can only be used in the lambda of 'produce'"
        )

private val draftContextLocal = ThreadLocal<SyncDraftContext>()

/**
 * Create new data by old data and asynchronous user code.
 *
 * In general, developer will not call this function directly.
 * *kimmer-ksp* will generate more friendly inline functions to wrap it.
 *
 * @param type The immutable interface type
 * @param base The original immutable data, this function creates new data based on it.
 * If it's null, that means to create data from scratch.
 * @param block The user code to modify the draft object.
 * @return The new immutable data.
 */
suspend fun <T: Immutable> produceAsync(
    type: KClass<T>,
    base: T? = null,
    block: suspend Draft<T>.() -> Unit
): T =
    currentCoroutineContext()[DraftContextElement]?.ctx?.let {
        it.createDraft(type, base).apply {
            block()
        } as T
    } ?: AsyncDraftContext().let {
        withContext(DraftContextElement(it)) {
            it.createDraft(type, base).let { draft ->
                draft.block()
                (draft as DraftSpi).`{resolve}`() as T
            }
        }
    }

/**
 * Create new draft by old data and asynchronous user code.
 *
 * - In general, developer will not call this function directly.
 *   *kimmer-ksp* will generate more friendly inline functions to wrap it.
 *
 * - This function can only be called in the lambda of [produceAsync],
 *   otherwise, an [UnsupportedOperationException] will be raised.
 *
 * @param type The immutable interface type
 * @param base The original immutable data, this function creates new data based on it.
 * If it's null, that means to create data from scratch.
 * @param block The user code to modify the draft object.
 * @return The new mutable draft.
 * @exception UnsupportedOperationException This function isn't called under the lambda of [produceAsync]
 */
suspend fun <T: Immutable, D: AsyncDraft<T>> produceDraftAsync(
    type: KClass<T>,
    base: T? = null,
    block: suspend D.() -> Unit
): D =
    currentCoroutineContext()[DraftContextElement]
        ?.let { it.ctx }
        ?.let {
            val draft = it.createDraft(type, base) as D
            draft.block()
            return draft
        } ?: throw UnsupportedOperationException(
        "'produceDraftAsync' can only be used in the lambda of 'produceAsync'"
    )

private data class DraftContextElement(
    val ctx: AsyncDraftContext
) : AbstractCoroutineContextElement(DraftContextElement) {
    companion object Key : CoroutineContext.Key<DraftContextElement>
}