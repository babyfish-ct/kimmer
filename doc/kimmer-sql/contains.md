# [Home](https://github.com/babyfish-ct/kimmer)/[kimmer-sql](./README.md)/Contains

## 1. Collection join

In the previous chapter, we discussed table joins in depth

Now let's look at a few joins

1. Join the one-to-many assocaition *BookStore::books*

```kt
sqlClient.createQuery(BookStore::class) {
    where(table.books.name eq "Learnning GraphQL")
    select(table)
}
```

2. Join the many-to-many assocaition *Book::authors*
```kt
sqlClient.createQuery(Book::class) {
    where(table.authors.firstName eq "Alex")
    select(table)
}
```

3. Join the one-to-many assocaition *Auhtor::books*

```kt
sqlClient.createQuery(Author::class) {
    where(table.books.name eq "Learnning GraphQL")
    select(table)
}
```

In this code we can see joins: ```table.books```, ```table.authors```, they target one-to-many associations or many-to-many associations.

**Precise definition**

*list* = kotlin.collections.List<*>

*connection* = [org.babyfish.kimmer.graphql.Connection<*>](../../project/kimmer/src/main/kotlin/org/babyfish/kimmer/graphql/Connection.kt)

**collection** = *list* | *connection*

> [org.babyfish.kimmer.graphql.Connection](../../project/kimmer/src/main/kotlin/org/babyfish/kimmer/graphql/Connection.kt) is used to support [graphql-connection](https://relay.dev/graphql/connections.htm), kimmer-sql cannot support it on its own, it must be supported in conjunction with new framework for GraphQL in the future. For now, let's ignore the connection for now.

If a join is created by association whose type is collection *(list | connection)*, it is a collection join. This is the precise definition.

## 2. Disadvantages of collection joins

Collection join will cause duplicate data after SQL join

- If the developer forgets to deduplicate, there will be a bug

- If not all columns need to be deduplicated(ORM often need only to deduplicate the fields of parent object), the *select distinct* of SQL cannot be used. People often choose to use *java.util.LinkedHashSet* on the client side to deduplicate, but this is not good for either the network or the JVM.

- Duplicate data is not friendly to pagination, this is the most developer-headed sentence in the Hibernate log

    [firstResult/maxResults specified with collection fetch; applying in memory](https://tech.asimio.net/2021/05/19/Fixing-Hibernate-HHH000104-firstResult-maxResults-warning-using-Spring-Data-JPA.html)

So, the disadvantages of using a collection join in a top-level query are too significant, but there is still value in using a collection join in a subquery.

kimmer-ksp support useful a useful switch for the developer, it's *kimmer.table.collection-join-only-for-sub-query*

If the developer turns on this switch, the following can be achieved at compile time

1. Prohibit the use of collection joins in top-level queries
2. Allow collection joins in subqueries

### 3. kimmer.table.collection-join-only-for-sub-query

Now let's discuss the switch of kimmer-ksp, what is the difference between the code generated by kimmer-ksp for different configurations.

```
ksp {
    arg("kimmer.draft", "false")
    arg("kimmer.table", "true")
    arg("kimmer.table.collection-join-only-for-sub-query", "false") // Here it is
}
```

You can modify this switch in gradle.kts file

- false (default): allow top-level queries to use collection joins
- true: disable top-level queries from using collection joins

Let's review a query we saw in Chapter [Null safety](./null-safety.md)

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        where {
            tuple {
                table.name then   // α
                    table.edition
            } valueIn subQuery(Book::class) {
                groupBy(table.name)
                select {
                    table.name then    // β
                        table.edition.max().asNonNull()
                }
            }
        }
        select(table)
    }
    .execute(con)
```

1. At the line with comment *α*, *table* is an implicit object providered by kimmer-sql, it's the primary table of top-level query and its type is [NonNullJoinableTable](../../project/kimmer-sql/src/main/kotlin/org/babyfish/kimmer/sql/ast/table/NonNullJoinableTable.kt)

2. At the line with comment *β*, *table* is another implicit object providered by kimmer-sql, it's the primary table of sub-query and its type is [NonNullSubQueryTable](../../project/kimmer-sql/src/main/kotlin/org/babyfish/kimmer/sql/ast/table/NonNullSubQueryTable.kt)

Use the collection join *Book::authors* to be example

When *kimmer.table.collection-join-only-for-sub-query* is false, the source code generated by kimmer-ksp is
```kt
public val SubQueryTable<Book, UUID>.authors: NonNullSubQueryTable<Author, UUID>   // α
  get() = joinList(Book::authors)

public val SubQueryTable<Book, UUID>.`authors?`: SubQueryTable<Author, UUID>   // β
  get() = `joinList?`(Book::authors)

public val JoinableTable<Book, UUID>.authors: NonNullJoinableTable<Author, UUID>   // γ
  get() = joinList(Book::authors)

public val JoinableTable<Book, UUID>.`authors?`: JoinableTable<Author, UUID>   // δ
  get() = `joinList?`(Book::authors)
```

1. *α* and *β*, the collection join *Book::authors* is allowed to be used by subqueries.
2. *α* and *β*, the collection join *Book::authors* is allowed to be used by top level queries.

When *kimmer.table.collection-join-only-for-sub-query* is false, the source code generated by kimmer-ksp is
```kt
public val SubQueryTable<Book, UUID>.authors: NonNullSubQueryTable<Author, UUID>
  get() = joinList(Book::authors)

public val SubQueryTable<Book, UUID>.`authors?`: SubQueryTable<Author, UUID>
  get() = `joinList?`(Book::authors)
```

Obviously, *Book::authors* can only be used by subqueries, using it in a top-level query results in a compile error.

> Encourage developers to flip this switch and maintain good programming habits

## 4. Contains

Now, let's get to the main topic of this article

Through chapter [Table joins](./table-joins.md), we know phantom joins and half joins, which are very helpful for performance when the query condition of the associated object is only for the *id* field.

Now, collection joins for top-level queries are disabled. Although subqueries can solve everything, kimmer-sql still allows developers to not need to write subqueries for id-based filtering.

kimmer-sql provides an alternative that works similarly to phantom joins and half joins where collection joins of top-level query is disabled.

### 4.1. containsAny

If the current object has a collection assocation, checked whether the ids of associated objects contain any element of a specified id list.

1. Example for one-to-many association *BookStore::books* without middle table
    ```kt
    val query = sqlClient.createQuery(BookStore::class) {
        where {
            table `books ∩` listOf(
                UUID.fromString("e110c564-23cc-4811-9e81-d587a13db634"),
                UUID.fromString("914c8595-35cb-4f67-bbc7-8029e9e6245a")
            )
        }
        select(table)
    }
    query.execute(con)
    ```
    
    The generated SQL is as follows
    
    ```sql
    select tb_1_.ID, tb_1_.NAME, tb_1_.WEBSITE 
    from BOOK_STORE as tb_1_ 
    where tb_1_.ID = any(
        select STORE_ID from BOOK where ID in (?, ?)
    )
    ```

2. Example for many-to-many association *Author::books* with middle table *BOOK_AUTHOR_MAPPING*
    ```kt
    val query = sqlClient.createQuery(Author::class) {
        where {
            table `books ∩` listOf(
                UUID.fromString("e110c564-23cc-4811-9e81-d587a13db634"),
                UUID.fromString("914c8595-35cb-4f67-bbc7-8029e9e6245a")
            )
        }
        select(table)
    }
    query.execute(con)
    ```
    
    The generated SQL is as follows
    
    ```sql
    select tb_1_.ID, tb_1_.FIRST_NAME, concat(tb_1_.FIRST_NAME, ?, tb_1_.LAST_NAME), tb_1_.LAST_NAME 
    from AUTHOR as tb_1_ 
    where tb_1_.ID = any(
        select AUTHOR_ID from BOOK_AUTHOR_MAPPING where BOOK_ID in (?, ?)
    )
    ```

### 4.2. containsAll

If the current object has a collection assocation, checked whether the ids of associated objects contain all elements of a specified id list.

1. Example for one-to-many association *BookStore::books* without middle table
    ```kt
    val query = sqlClient.createQuery(BookStore::class) {
        where {
            table `books ∋` listOf(
                UUID.fromString("e110c564-23cc-4811-9e81-d587a13db634"),
                UUID.fromString("914c8595-35cb-4f67-bbc7-8029e9e6245a")
            )
        }
        select(table)
    }
    query.execute(con)
    ```
    
    The generated SQL is as follows
    
    ```sql
    select tb_1_.ID, tb_1_.NAME, tb_1_.WEBSITE 
    from BOOK_STORE as tb_1_ 
    where tb_1_.ID = all(
        select STORE_ID from BOOK where ID in (?, ?)
    )
    ```

2. Example for many-to-many association *Author::books* with middle table *BOOK_AUTHOR_MAPPING*
    ```kt
    val query = sqlClient.createQuery(Author::class) {
        where {
            table `books ∋` listOf(
                UUID.fromString("e110c564-23cc-4811-9e81-d587a13db634"),
                UUID.fromString("914c8595-35cb-4f67-bbc7-8029e9e6245a")
            )
        }
        select(table)
    }
    query.execute(con)
    ```
    
    The generated SQL is as follows
    
    ```sql
    select tb_1_.ID, tb_1_.FIRST_NAME, concat(tb_1_.FIRST_NAME, ?, tb_1_.LAST_NAME), tb_1_.LAST_NAME 
    from AUTHOR as tb_1_ 
    where tb_1_.ID = all(
        select AUTHOR_ID from BOOK_AUTHOR_MAPPING where BOOK_ID in (?, ?)
    )
    ```
    

------------------
[< Previous: Table joins](./table-joins.md) | [Back to parent](./README.md) | [Next: Subqueries >](./subqueries.md)
