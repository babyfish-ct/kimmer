# [Home](https://github.com/babyfish-ct/kimmer)/[kimmer-sql](./README.md)/Containss

## 1. Collection join

In the previous chapter, we discussed table joins in depth

Now let's look at a few joins

1. Join the one-to-many assocaition *BookStore::books*

```kt
sqlClient.createQuery(BookStore::class) {
    where(table.books.name eq "Learnning GraphQL")
    select(table)
}
```

2. Join the many-to-many assocaition *Book::authors*
```kt
sqlClient.createQuery(Book::class) {
    where(table.authors.firstName eq "Alex")
    select(table)
}
```

3. Join the one-to-many assocaition *Auhtor::books*

```kt
sqlClient.createQuery(Author::class) {
    where(table.books.name eq "Learnning GraphQL")
    select(table)
}
```

In this code we can see joins: ```table.books```, ```table.authors```, they target one-to-many associations or many-to-many associations.

**Precise definition**

*list* = kotlin.collections.List<*>

*connection* = [org.babyfish.kimmer.graphql.Connection<*>](../../project/kimmer/src/main/kotlin/org/babyfish/kimmer/graphql/Connection.kt)

**collection** = *list* | *connection*

> [org.babyfish.kimmer.graphql.Connection](../../project/kimmer/src/main/kotlin/org/babyfish/kimmer/graphql/Connection.kt) is used to support [graphql-connection](https://relay.dev/graphql/connections.htm), kimmer-sql cannot support it on its own, it must be supported in conjunction with new framework for GraphQL in the future. For now, let's ignore the connection for now.

If a join is created by association whose type is collection *(list | connection)*, it is a collection join. This is the precise definition.

## 2. Disadvantages of collection joins

Collection join will cause duplicate data after SQL join

- If the developer forgets to deduplicate, there will be a bug

- If there are many columns to be queried (such as querying the entire object, or even querying multiple objects), it is not a good choice to remove duplicates through *select distinct* of SQL. People often choose to use *java.util.LinkedHashSet* on the client side to deduplicate. But this is not good for either the network or the JVM.

- Duplicate data is not friendly to pagination, this is the most developer-headed sentence in the Hibernate log

    [firstResult/maxResults specified with collection fetch; applying in memory](https://tech.asimio.net/2021/05/19/Fixing-Hibernate-HHH000104-firstResult-maxResults-warning-using-Spring-Data-JPA.html)

So, the disadvantages of using a collection join in a top-level query are too significant, but there is still value in using a collection join in a subquery.

kimmer-ksp support useful a useful switch for the developer, it's *kimmer.table.collection-join-only-for-sub-query*

If the developer turns on this switch, the following can be achieved at compile time

1. Prohibit the use of collection joins in top-level queries
2. Allow collection joins in subqueries

### 3. kimmer.table.collection-join-only-for-sub-query

Now let's discuss the switch of kimmer-ksp, what is the difference between the code generated by kimmer-ksp for different configurations.

```
ksp {
    arg("kimmer.draft", "false")
    arg("kimmer.table", "true")
    arg("kimmer.table.collection-join-only-for-sub-query", "false") // Here it is
}
```

You can modify this switch in gradle.kts file

- false (default): allow top-level queries to use collection joins
- true: disable top-level queries from using collection joins

------------------
[< Previous: Table joins](./table-joins.md) | [Back to parent](./README.md) | [Next: Subqueries >](./subqueries.md)
