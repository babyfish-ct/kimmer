# [Home](https://github.com/babyfish-ct/kimmer)/[kimmer-sql](./README.md)/Containss

## 1. Collection join

In the previous chapter, we discussed table joins in depth

Now let's look at a few joins

1. Join the one-to-many assocaition *BookStore::books*

```kt
sqlClient.createQuery(BookStore::class) {
    where(table.books.name eq "Learnning GraphQL")
    select(table)
}
```

2. Join the many-to-many assocaition *Book::authors*
```kt
sqlClient.createQuery(Book::class) {
    where(table.authors.firstName eq "Alex")
    select(table)
}
```

3. Join the one-to-many assocaition *Auhtor::books*

```kt
sqlClient.createQuery(Author::class) {
    where(table.books.name eq "Learnning GraphQL")
    select(table)
}
```

In this code we can see joins: ```table.books```, ```table.authors```, they target one-to-many associations or many-to-many associations.

**Precise definition**

*list* = kotlin.collections.List<*>

*connection* = [org.babyfish.kimmer.graphql.Connection<*>](../../project/kimmer/src/main/kotlin/org/babyfish/kimmer/graphql/Connection.kt)

**collection** = *list* | *connection*

> [org.babyfish.kimmer.graphql.Connection](../../project/kimmer/src/main/kotlin/org/babyfish/kimmer/graphql/Connection.kt) is used to support [graphql-connection](https://relay.dev/graphql/connections.htm), kimmer-sql cannot support it on its own, it must be supported in conjunction with new framework for GraphQL in the future. For now, let's ignore the connection for now.

If a join is created by association whose type is collection *(list | connection)*, it is a collection join. This is the precise definition.

## 2. Disadvantages of collection joins

Collection join will cause duplicate data after SQL join

- If the developer forgets to deduplicate, there will be a bug

- If there are many columns to be queried (such as querying the entire object, or even querying multiple objects), it is not a good choice to remove duplicates through *select distinct* of SQL. People often choose to use *java.util.LinkedHashSet* on the client side to deduplicate. But this is not good for either the network or the JVM.

- Duplicate data is not friendly to pagination, this is the most developer-headed sentence in the Hibernate log

    [firstResult/maxResults specified with collection fetch; applying in memory](https://tech.asimio.net/2021/05/19/Fixing-Hibernate-HHH000104-firstResult-maxResults-warning-using-Spring-Data-JPA.html)

So, the disadvantages of using a collection join in a top-level query are too significant, but there is still value in using a collection join in a subquery.

kimmer-ksp support useful a useful switch for the developer, it's *kimmer.table.collection-join-only-for-sub-query*

If the developer turns on this switch, the following can be achieved at compile time

1. Prohibit the use of collection joins in top-level queries
2. Allow collection joins in subqueries

### 3. kimmer.table.collection-join-only-for-sub-query

Now let's discuss the switch of kimmer-ksp, what is the difference between the code generated by kimmer-ksp for different configurations.

```
ksp {
    arg("kimmer.draft", "false")
    arg("kimmer.table", "true")
    arg("kimmer.table.collection-join-only-for-sub-query", "false") // Here it is
}
```

You can modify this switch in gradle.kts file

- false (default): allow top-level queries to use collection joins
- true: disable top-level queries from using collection joins

Let's review a query we saw in Chapter [Null safety](./null-safety.md)

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        where {
            tuple {
                table.name then   // α
                    table.edition
            } valueIn subQuery(Book::class) {
                groupBy(table.name)
                select {
                    table.name then    // β
                        table.edition.max().asNonNull()
                }
            }
        }
        select(table)
    }
    .execute(con)
```

1. At the line with comment *α*, *table* is an implicit object providered by kimmer-sql, it's the primary table of top-level query and its type is [NonNullJoinableTable](../../project/kimmer-sql/src/main/kotlin/org/babyfish/kimmer/sql/ast/table/NonNullJoinableTable.kt)

2. At the line with comment *β*, *table* is another implicit object providered by kimmer-sql, it's the primary table of sub-query and its type is [NonNullSubQueryTable](../../project/kimmer-sql/src/main/kotlin/org/babyfish/kimmer/sql/ast/table/NonNullSubQueryTable.kt)

Use the collection join *Book::authors* to be example

When *kimmer.table.collection-join-only-for-sub-query* is false, the source code generated by kimmer-ksp is
```kt
public val SubQueryTable<Book, UUID>.authors: NonNullSubQueryTable<Author, UUID>   // α
  get() = joinList(Book::authors)

public val SubQueryTable<Book, UUID>.`authors?`: SubQueryTable<Author, UUID>   // β
  get() = `joinList?`(Book::authors)

public val JoinableTable<Book, UUID>.authors: NonNullJoinableTable<Author, UUID>   // γ
  get() = joinList(Book::authors)

public val JoinableTable<Book, UUID>.`authors?`: JoinableTable<Author, UUID>   // δ
  get() = `joinList?`(Book::authors)
```

1. *α* and *β*, the collection join *Book::authors* is allowed to be used by subqueries.
2. *α* and *β*, the collection join *Book::authors* is allowed to be used by top level queries.

When *kimmer.table.collection-join-only-for-sub-query* is false, the source code generated by kimmer-ksp is
```
public val SubQueryTable<Book, UUID>.authors: NonNullSubQueryTable<Author, UUID>
  get() = joinList(Book::authors)

public val SubQueryTable<Book, UUID>.`authors?`: SubQueryTable<Author, UUID>
  get() = `joinList?`(Book::authors)
```

Obviously, *Book::authors* can only be used by subqueries, using it in a top-level query results in a compile error.

------------------
[< Previous: Table joins](./table-joins.md) | [Back to parent](./README.md) | [Next: Subqueries >](./subqueries.md)
