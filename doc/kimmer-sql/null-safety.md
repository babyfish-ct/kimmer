# [Home](https://github.com/babyfish-ct/kimmer)/[kimmer-sql](./README.md)/Null safety

Kimmer-ksp provide null safety for SQL, like the null safety of kotlin

## 1. Nullity of column

BookStore supports two properties, *BookStore::name* and *BookStorewebsite*. 

*BookStore::name* is non null, *BookStore::website* is nullable

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(BookStore::class) {
        select { 
            table.name then table.website 
        }
    }
    .execute(con)
for ((name, website) in rows) {
    println(name.length)    // α
    println(website.length)    // β
}
```
- The line with comment "α" can be compiled correctly
- However, the line with comment "β" will result in a compilation error， because BookStore::website is nullable

## 2. Nullity of table

Book support a many-to-one association *Book::store*

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        select(table.store)
    }
    .execute(con)
for (store in rows) {
    println(store.name)
}
```
This code can be compiled and run successfully, because *table.store* means inner join. 

Inner join always return nonnull table regardless of whether the association itself is nullable or not.

Let's look at another example
```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        select(table.`store?`)
    }
    .execute(con)
for (store in rows) {
    println(store.name)    // α
}
```    

The line with comment "α" will result in a compilation error, store is a nullable object because *table.store?* means left join. 

Left join always return nonnull table regardless of whether the association itself is nullable or not.

## 3. Nonnull column of nullable table

*BookStore::name* is a non null property.

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        select(table.`store?`.name)
    }
    .execute(con)
for (name in rows) {
    println(name.length)    // α
}
```

The line with comment "α" will result in a compilation error.

Although *BookStore::name* is a nonnull property, its it is created by the left join *table.store?*, so its data type in the query result is still nullable.

How is this function implemented? Let me take a look at the source code generated by kimmer-ksp.

```kt
// Get nonnull column from nonnull table, returns nonnull expression
public val NonNullTable<BookStore, UUID>.name: NonNullExpression<String>
  get() = get(BookStore::name)

// Get nonnull column from nullable table, still returns nullable expression
public val Table<BookStore, UUID>.name: Expression<String>
  get() = `get?`(BookStore::name)
```

## 4. Nullity of evaluate expression

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        select {
            table.price + BigDecimal(1) then 
                table.price + nullValue(BigDecimal::class)
        }
    }
    .execute(con)
for ((p1, p2) in rows) {
    println(p1.scale()) // α
    println(p2.scale()) // β
}
```

- The line with comment "α" can be compiled correctly.

    Both sides of the *+* are non-null expressions, and the result is also nonnullable
    
- However, the line with comment "β" will result in a compilation error， because BookStore::website is nullable

    Either side of the *+* is a nullable expression, the result is nullable
    
Similarly, many other operators have this feature, which will not be described here.

## 5. Nullity of case expression

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        select(
            case()
                .match(table.price lt BigDecimal(100), "Cheap")
                .match(table.price gt BigDecimal(200), "Expensive")
                .otherwise("Middle")
        )
    }
    .execute(con)
for (str in rows) {
    println(str.length)
}
```

This code can be compiled and run successfully, the result is nonnull when all branches of the case expression return nonnull.

However, the result will be nullable when either branch of the case expression is nullable.

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        select(
            case()
                .match(table.price lt BigDecimal(100), "Cheap")
                .match(table.price gt BigDecimal(200), nullValue(String::class))
                .otherwise("Middle")
        )
    }
    .execute(con)
for (str in rows) {
    println(str.length)   // α
}
```

The line with comment "α" will result in a compilation error, the second branch of the case expression returns nullable type causing the entire case expression to return nullable type.

## 6. Nullity of coalesce

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(BookStore::class) {
        select(
            coalesce(table.website)
                .or("https://www.jetbrains.com/")
                .or(nullValue(String::class))
                .end()
        )
    }
    .execute(con)
for (website in rows) {
    println(website.length)
}
```
This code can be compiled and run successfully, The coalesce expression returns nonnull type when any one of its choice returns nonnull type.

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(BookStore::class) {
        select(
            coalesce(table.website)
                .or(nullValue(String::class))
                .or(nullValue(String::class))
                .end()
        )
    }
    .execute(con)
for (website in rows) {
    println(website.length)    // α
}
```
The line with comment "α" will result in a compilation error, Coalesce expression returns nullable type when all the choices returns nullable type.

>   For coalesce expressions with only two options, there is a quick way to write it
>  
>   ```select(coalesce(table.website, "https://www.jetbrains.com/"))```

## 7. asNonNullable

In most cases, null-safety can work well to help you get more secure code.

However, sometimes, it can have negative effects

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        where { 
            tuple { 
                table.name then 
                    table.edition 
            } valueIn subQuery(Book::class) {
                groupBy(table.name)
                select {    // α
                    table.name then 
                        table.edition.max()
                }
            }
        }
        select(table)
    }
    .execute(con)
```

The line with comment "α" will result in a compilation error

```
Type mismatch.
Required:
TypedSubQuery<Book, UUID, Book, UUID, Pair<String, Int>>
Found:
ConfigurableTypedSubQuery<Book, UUID, Book, UUID, Pair<String, Int?>>
```

The aggregate function *max()* may return null, which can be caused by aggregating an empty collection.

So, the return type of the subquery is *Pair<String, Int?>*. However, the tuple type on the left side of *valueIn* is *Pair<String, Int>*, the mismatch between them in a compilation error.

However, when *max()* is used together with group by, it is never possible for *max()* to return null because empty groups cannot appear in the query results. This query has no problem.

At this time, *asNonNull()* can help you to treat the *max()* function as a non-null expression.

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        where {
            tuple {
                table.name then
                    table.edition
            } valueIn subQuery(Book::class) {
                groupBy(table.name)
                select {
                    table.name then
                        table.edition.max().asNonNull()
                }
            }
        }
        select(table)
    }
    .execute(con)
```

------------------
[< Previous: Get started](./get-started.md) | [Back to parent](./README.md) | [Next: Table joins >](./table-joins.md)
