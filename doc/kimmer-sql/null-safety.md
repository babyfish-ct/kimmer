# [Home](https://github.com/babyfish-ct/kimmer)/[kimmer-sql](./README.md)/Null safety

Kimmer-ksp provide null safety for SQL, like the null safety of kotlin

## 1. Nullity of column

BookStore supports two properties, *BookStore::name* and *BookStorewebsite*. 

*BookStore::name* is non null, *BookStore::website* is nullable

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(BookStore::class) {
        select { 
            table.name then table.website 
        }
    }
    .execute(con)
for ((name, website) in rows) {
    println(name.length)    // α
    println(website.length)    // β
}
```
- The line with comment "α" can be compiled correctly
- However, the line with comment "β" will result in a compilation error， because BookStore::website is nullable

## 2. Nullity of table

Book support a many-to-one association *Book::store*

```kt
val sqlClient = ... some code to get sql client ...
val con = ... some code to get JDBC/R2DBC connection ...

val rows = sqlClient
    .createQuery(Book::class) {
        select(table.store)
    }
    .execute(con)
for (store in rows) {
    println(store.name)
}
```
This code can be compiled and run successfully, because *table.store* means inner join. 

Inner join always return nonnull table regardless of whether the association itself is nullable or not.

Let's look at another example
```kt
val rows = sqlClient
    .createQuery(Book::class) {
        select(table.`store?`)
    }
    .execute(con)
for (store in rows) {
    println(store.name)    // α
}
```    

the line with comment "β" will result in a compilation error, store is a nullable object because *table.store?* means left join. 

Left join always return nonnull table regardless of whether the association itself is nullable or not.

## 3. NonNull column of nullable table

*BookStore::name* is a non null property.

```kt
val rows = sqlClient
    .createQuery(Book::class) {
        select(table.`store?`.name)
    }
    .execute(con)
for (name in rows) {
    println(name.length)    // α
}
```

Although *BookStore::name* is a nonnull property, its it is created by the left join *table.store?*, so its data type in the query result is still nullable.

How is this function implemented? Let me take a look at the source code generated by kimmer-ksp.

```kt
// Get nonnull column from nonnull table, returns nonnull expression
public val NonNullTable<BookStore, UUID>.name: NonNullExpression<String>
  get() = get(BookStore::name)

// Get nonnull column from nullable table, still returns nullable expression
public val Table<BookStore, UUID>.name: Expression<String>
  get() = `get?`(BookStore::name)
```

------------------
[< Previous: Get started](./get-started.md) | [Back to parent](./README.md) | [Next: Table joins >](./table-joins.md)
